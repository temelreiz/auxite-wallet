"use client";

import { useEffect, useState, useRef } from "react";
import { ethers } from "ethers";
import { METALS, type MetalId } from "@/lib/metals";
import AuxiteTokenAbi from "@/lib/abi/AuxiteToken.json";

export type PriceDirection = "up" | "down" | "same";

export interface MetalPrice {
  id: MetalId;
  symbol: string;
  name: string;
  pricePerGramAsk: number | null;
  pricePerGramBid: number | null;
  ts: number | null;
}

type PricesMap = Record<MetalId, number | null>;
type BidPricesMap = Record<MetalId, number | null>;
type DirectionsMap = Record<MetalId, PriceDirection>;
type HistoryMap = Record<MetalId, number[]>;

interface UseMetalsPricesResult {
  prices: PricesMap;
  bidPrices: BidPricesMap;
  directions: DirectionsMap;
  history: HistoryMap;
  loading: boolean;
  error: string | null;
  lastUpdated: Date | null;
}

const METAL_ADDRESSES: Record<MetalId, string | undefined> = {
  AUXG: process.env.NEXT_PUBLIC_AUXG_ADDRESS,
  AUXS: process.env.NEXT_PUBLIC_AUXS_ADDRESS,
  AUXPT: process.env.NEXT_PUBLIC_AUXPT_ADDRESS,
  AUXPD: process.env.NEXT_PUBLIC_AUXPD_ADDRESS,
};

const TOKEN_ABI = AuxiteTokenAbi as any;

function createInitialPrices(): PricesMap {
  return METALS.reduce((acc, m) => {
    acc[m.id] = null;
    return acc;
  }, {} as PricesMap);
}

function createInitialDirections(): DirectionsMap {
  return METALS.reduce((acc, m) => {
    acc[m.id] = "same";
    return acc;
  }, {} as DirectionsMap);
}

function createInitialHistory(): HistoryMap {
  return METALS.reduce((acc, m) => {
    acc[m.id] = [];
    return acc;
  }, {} as HistoryMap);
}

export function useMetalsPrices(): UseMetalsPricesResult {
  const [mounted, setMounted] = useState(false);
  const [prices, setPrices] = useState<PricesMap>(() => createInitialPrices());
  const [bidPrices, setBidPrices] = useState<BidPricesMap>(() => createInitialPrices());
  const [directions, setDirections] = useState<DirectionsMap>(() =>
    createInitialDirections()
  );
  const [history, setHistory] = useState<HistoryMap>(() =>
    createInitialHistory()
  );
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

  const lastPricesRef = useRef<PricesMap | null>(null);

  // Client-side mount kontrolü (hydration hatası önleme)
  useEffect(() => {
    setMounted(true);
  }, []);

  async function fetchPricesFromContracts() {
    try {
      setError(null);

      if (typeof window === "undefined") return;
      
      const rpcUrl = process.env.NEXT_PUBLIC_SEPOLIA_RPC_URL || 
                     "https://sepolia.infura.io/v3/06f4a3d8bae44ffb889975d654d8a680";
      
      const provider = new ethers.JsonRpcProvider(rpcUrl);

      const nextPrices: PricesMap = createInitialPrices();
      const nextBidPrices: BidPricesMap = createInitialPrices();

      // Her metal için kontratları paralel olarak oku
      const pricePromises = METALS.map(async (metal) => {
        const address = METAL_ADDRESSES[metal.id];
        if (!address) return;

        try {
          const contract = new ethers.Contract(address, TOKEN_ABI, provider);

          // ASK fiyatı (USD/g * 1e6)
          const askGramE6: bigint = await contract.pricePerGramAskE6();
          const askUsdG = Number(askGramE6) / 1_000_000;

          // BID fiyatı (USD/g * 1e6)
          const bidGramE6: bigint = await contract.pricePerGramBidE6();
          const bidUsdG = Number(bidGramE6) / 1_000_000;

          nextPrices[metal.id] = askUsdG;
          nextBidPrices[metal.id] = bidUsdG;

        } catch (e) {
          console.error(`Fiyat alınamadı (${metal.symbol}):`, e);
        }
      });

      await Promise.all(pricePromises);

      // Yön hesapla
      setDirections((prev) => {
        const next = { ...prev };
        const last = lastPricesRef.current;

        METALS.forEach((m) => {
          const id = m.id;
          const newP = nextPrices[id];
          const oldP = last?.[id];

          if (newP == null || oldP == null) {
            next[id] = "same";
          } else if (newP > oldP) {
            next[id] = "up";
          } else if (newP < oldP) {
            next[id] = "down";
          } else {
            next[id] = "same";
          }
        });

        return next;
      });

      // History güncelle
      setHistory((prev) => {
        const next: HistoryMap = { ...prev };
        METALS.forEach((m) => {
          const id = m.id;
          const p = nextPrices[id];
          if (p != null) {
            const prevArr = next[id] ?? [];
            next[id] = [...prevArr, p].slice(-60);
          }
        });
        return next;
      });

      lastPricesRef.current = nextPrices;
      setPrices(nextPrices);
      setBidPrices(nextBidPrices);
      setLastUpdated(new Date());
      setLoading(false);
    } catch (e: any) {
      console.error("Fiyat çekme hatası:", e);
      setError(e?.message ?? "Fiyatlar alınırken hata oluştu");
      setLoading(false);
    }
  }

  useEffect(() => {
    if (!mounted) return;
    
    fetchPricesFromContracts();
    
    const interval = setInterval(fetchPricesFromContracts, 10_000);
    
    return () => clearInterval(interval);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [mounted]);

  return {
    prices,
    bidPrices,
    directions,
    history,
    loading,
    error,
    lastUpdated,
  };
}